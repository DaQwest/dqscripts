# encoding: UTF-8

@combdesc = {"Cycle detection"=>{}, "Floyd's cycle-finding algorithm"=>{}, "Stable marriage problem"=>{"wolfram"=>"\nGiven a set of  men and  women, marry them\n off in pairs after each man has ranked the women in order of preference from 1 to\n ,  and\n each women has done likewise, . If\n the resulting set of marriages contains no pairs of the\n form ,  such that\n  prefers  to  and  prefers  to , the marriage\n is said to be stable. Gale and Shapley (1962) showed that a stable marriage exists\n for any choice of rankings (Skiena 1990, p. 245). In the United States, the\n algorithm of Gale and Shapley (1962) is used to match hospitals to medical interns\n (Skiena 1990, p. 245).\n"}, "Pseudorandom number generator"=>{"xlinux.nist.gov"=>"\n\nA deterministic algorithm to generate a sequence of numbers with little or no discernible pattern in the numbers, except for broad statistical properties.\n", "wolfram"=>"\nA slightly archaic term for a computer-generated random number. The prefix pseudo- is used to distinguish this type of number from a\n \"truly\" random number generated by a random\n physical process such as radioactive decay.\n"}, "Blum Blum Shub"=>{"wolfram"=>"The ability to generate pseudorandom numbers is important for simulating events, estimating probabilities and other quantities, making randomized assignments or selections, and numerically testing symbolic results. Such applications may require uniformly distributed numbers, nonuniformly distributed numbers, elements sampled with replacement, or elements sampled without replacement. "}, "Lagged Fibonacci generator"=>{}, "Linear congruential generator"=>{"wolfram"=>"\nA method for generating random (pseudorandom) numbers using the linear recurrence relation\n\nwhere  and  must assume certain\n fixed values,  is some chosen modulus, and  is an initial\n number known as the seed.\n", "xlinux.nist.gov"=>"\n\nA class of algorithms that are pseudo-random number generators.  The next number is generated from the current one by  rn+1 = (A × rn + B) mod  M, where A and M are relatively prime numbers.\n"}, "Mersenne twister"=>{"wolfram"=>"Embed Interactive Demonstration New!Files require Wolfram CDF Player or Mathematica."}, "Flow network"=>{"xlinux.nist.gov"=>"\n\nA weighted, directed graph with two specially marked nodes, the source s and the sink t, and a capacity function that maps edges to positive real numbers, u: E |→ R+.\n"}, "General Problem Solver"=>{}, "Phonetic algorithm"=>{}, "Daitch–Mokotoff Soundex"=>{}, "Double Metaphone algorithm"=>{"xlinux.nist.gov"=>"\n\nAn algorithm to code English words (and foreign words often heard in the United States) phonetically by reducing them to a combination of 12 consonant sounds.   It returns two codes if a word has two plausible pronunciations, such as a foreign word. This reduces matching problems from wrong spelling.\n"}, "Match Rating Approach"=>{}, "Metaphone algorithm"=>{"xlinux.nist.gov"=>"\n\nAn algorithm to code English words (and foreign words often heard in the United States) phonetically by reducing them to a combination of 12 consonant sounds.   It returns two codes if a word has two plausible pronunciations, such as a foreign word. This reduces matching problems from wrong spelling.\n"}, "New York State Identification and Intelligence System"=>{"xlinux.nist.gov"=>"\n\nConvert a name to a phonetic coding of up to six characters.\n"}, "Soundex algorithm"=>{}, "String metrics"=>{}, "Dice's coefficient"=>{}, "Trigram search"=>{}, "Linear search"=>{"xlinux.nist.gov"=>"\n\nSearch an array or list by checking items one at a time.\n"}, "Selection algorithm"=>{"wolfram"=>"Automatic algorithm selection (AAS) is the underlying technology that\r\t\t\tenables Mathematica to select and apply the best algorithm(s)\r\t\t\tfor a given task.System-wide implementation of AAS is unique to Mathematica and a key\r\t\t\tdistinguishing feature: other technical computing systems make the user\r\t\t\tspecify a single algorithm (not just the task) by hand, often from a confusing\r\t\t\tarray of possibilities. Get the selection wrong and your computation\r\t\t\tcould fail or, worse still, produce an inaccurate answer."}, "Ternary search"=>{"xlinux.nist.gov"=>"\n\nA 3-way tree where every node's left  subtree has keys less than the node's key, every middle subtree has keys equal to the node's key, and every right subtree has keys greater than the node's key.  If the key is a multikey (string, array, list, etc.), the middle subtree organizes by the next subkey (character, array or list item, etc.)\n"}, "Sorted list"=>{}, "Binary search algorithm"=>{"xlinux.nist.gov"=>"\n\nSearch a sorted array by repeatedly dividing the search interval in half.  Begin with an interval covering the whole array. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half.  Otherwise narrow it to the upper half.  Repeatedly check until the value is found or the interval is empty.\n", "wolfram"=>"\nA searching algorithm which works on a sorted table by testing the middle of an interval, eliminating the half of the table in which\n the key cannot lie, and then repeating the procedure iteratively.\n"}, "Fibonacci search technique"=>{}, "Jump search"=>{"xlinux.nist.gov"=>"\n\nSearch a sorted array by checking every jth item until the right area is found, then doing a linear search.  The optimum for n items is when j=√ n.\n"}, "Interpolation search"=>{"xlinux.nist.gov"=>"\n\nSearch a sorted array by estimating the next position to check based on a linear interpolation of the search key and the values at the ends of the search interval.\n", "wolfram"=>"Embed Interactive Demonstration New!Files require Wolfram CDF Player or Mathematica."}, "Uniform binary search"=>{}, "Fisher–Yates shuffle"=>{"xlinux.nist.gov"=>"\n\nRandomly permute N elements by exchanging each element ei with a random element from i to N. It consumes Θ(N log N) bits and runs in linear time.\n"}, "Schensted algorithm"=>{}, "Steinhaus–Johnson–Trotter algorithm"=>{"xlinux.nist.gov"=>"\n\nGenerate permutations by transposing one pair of elements at a time.\n"}, "Kadane's algorithm"=>{}, "Longest increasing subsequence problem"=>{"wolfram"=>"\nThe longest increasing scattered subsequence is the longest subsequence of increasing terms, where intervening nonincreasing terms may be dropped. Finding the largest\n scattered subsequence is a much harder problem. The longest increasing scattered\n subsequence of a partition can be found using LongestIncreasingSubsequence[p]\n in the Mathematica\n package Combinatorica` . For example, the longest increasing scattered subsequence\n of the permutation \n is , whereas\n the longest contiguous subsequence is .\n"}, "Substring search"=>{}, "Rabin–Karp string search algorithm"=>{}, "Ukkonen's algorithm"=>{"xlinux.nist.gov"=>"\n\nA compact representation of a trie corresponding to the suffixes of a given string where all nodes with one child are merged with their parents.\n"}}

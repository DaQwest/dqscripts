# encoding: UTF-8

@sortdesc = {"Bubble sort"=>{"xlinux.nist.gov"=>"\n\nSort by comparing each adjacent pair of items in a list in turn, swapping the items if necessary, and repeating the pass through the list until no swaps are done.\n"}, "Cocktail sort"=>{"xlinux.nist.gov"=>"\n\nA variant of bubble sort that compares each adjacent pair of items in a list in turn, swapping them if necessary, and alternately passes through the list from the beginning to the end then from the end to the beginning. It stops when a pass does no swaps.\n"}, "Comb sort"=>{"xlinux.nist.gov"=>"\n\nAn in-place sort algorithm that repeatedly reorders different pairs of items.  On each pass swap pairs of items separated by the increment or gap, if needed, and reduce the gap (divide it by about 1.3).  The gap starts at about 3/4 of the number of items.  Continue until the gap is 1 and a pass had no swaps.\n"}, "Gnome sort"=>{"xlinux.nist.gov"=>"\n\nPut items in order by comparing the current item with the previous item.  If they are in order, move to the next item (or stop if the end is reached).  If they are out of order, swap them and move to the previous item.  If there is no previous item, move to the next item.\n"}, "Odd-even sort"=>{}, "Quicksort"=>{"xlinux.nist.gov"=>"\n\nPick an element from the array (the pivot), partition the remaining elements into those greater than and less than this pivot, and recursively sort the partitions. There are many variants of the basic scheme above: to select the pivot, to partition the array, to stop the recursion on small partitions, etc.\n", "wolfram"=>"\nQuicksort is the fastest known comparison-based sorting algorithm (on average, and for a large number of elements),\n requiring  steps. Quicksort is a recursive\n algorithm which first partitions an array  according\n to several rules (Sedgewick 1978): \n"}, "Bogosort"=>{"xlinux.nist.gov"=>"\n\nA terribly inefficient sort algorithm that repeatedly generates a random permutation of the items until the items are in order.\n"}, "Stooge sort"=>{"xlinux.nist.gov"=>"\n\nA terribly inefficient sort algorithm that swaps the top and bottom items if needed, then (recursively) sorts the bottom two-thirds, then the top two-thirds, then the bottom two-thirds again.\n"}, "Flashsort"=>{"xlinux.nist.gov"=>"\n\n(no definition here, yet, but\nyou can help.)\n"}, "Introsort"=>{"xlinux.nist.gov"=>"\n\nA variant of quicksort which switches to heapsort for pathological inputs, that is, when execution time is becoming quadratic.\n"}, "Timsort"=>{}, "Insertion sort"=>{"xlinux.nist.gov"=>"\n\nSort by repeatedly taking the next item and inserting it into the final data structure in its proper order with respect to items already inserted.  Run time is O(n2) because of moves.\n"}, "Library sort"=>{}, "Patience sorting"=>{}, "Shell sort"=>{"xlinux.nist.gov"=>"\n\nThe first diminishing increment sort.  On each pass i sets of n/i items are sorted, typically with insertion sort.  On each succeeding pass, i is reduced until it is 1 for the last pass.  A good series of i values is important to efficiency.\n", "wolfram"=>"\nA sorting method proposed by Shell (1959) in which records being sorted can take long jumps instead of being restricted to short steps.\n\nKnuth, D. E. The Art of Computer Programming, Vol. 3: Sorting and Searching, 2nd ed.\n Reading, MA: Addison-Wesley, pp. 83-95, 1998.\n"}, "Tree sort"=>{}, "Cycle sort"=>{"wolfram"=>"\nA permutation cycle is a subset of a permutation whose elements trade places with one another. Permutations cycles are called \"orbits\"\n by Comtet (1974, p. 256). For example, in the permutation\n group , (143) is a 3-cycle and (2)\n is a 1-cycle. Here, the notation (143) means that starting from the original ordering\n , the first element is replaced by the fourth,\n the fourth by the third, and the third by the first, i.e., .\n"}, "Merge sort"=>{"xlinux.nist.gov"=>"\n\nA sort algorithm that splits the items to be sorted into two groups, recursively sorts each group, and  merges them into a final, sorted sequence.   Run time is Θ(n log n).\n", "wolfram"=>"\nA merge sort (or collation sort) is the combination of two or more ordered lists into a single ordered list (Knuth 1998, p. 158). Merge sorting was one of the first methods proposed for computer sorting, and was first proposed by John von Neumann in 1945 (Knuth 1998, p. 159). Variants include two-way, natural two-way, straight two-way, and list merge sorts.\n"}, "Strand sort"=>{"xlinux.nist.gov"=>"\n\nA sort algorithm that works well if many items are in order. First, begin a sublist by moving the first item from the original list to the sublist.  For each subsequent item in the original list, if it is greater than the last item of the sublist, remove it from the original list and append it to the sublist. Merge the sublist into a final, sorted list.  Repeatedly extract and merge  sublists until all items are sorted.  Handle two or fewer items as special cases.\n"}, "Bead sort"=>{"wolfram"=>"Embed Interactive Demonstration New!Files require Wolfram CDF Player or Mathematica."}, "Bucket sort"=>{"xlinux.nist.gov"=>"\n\nA distribution sort where input elements are initially  distributed to several buckets based on an interpolation of the element's key. Each bucket is sorted if necessary, and the buckets' contents are concatenated.\n"}, "Burstsort"=>{}, "Counting sort"=>{"xlinux.nist.gov"=>"\n\nA 2-pass sort algorithm that is efficient when the range of keys is small and there many duplicate keys.  The first pass counts the occurrences of each key in an auxiliary array, and then makes a running total so each auxiliary entry is the number of preceding keys.  The second pass puts each item in its final place according to the auxiliary entry for that key.\n"}, "Pigeonhole sort"=>{"xlinux.nist.gov"=>"\n\nA 2-pass sort algorithm that is efficient when the range of keys is approximately equal to the number of items.  The first pass allocates an array of buckets, one bucket for each possible key value, then moves each item to its key's bucket.  The second pass goes over the bucket array moving each item to the next place in the destination.\n"}, "Postman sort"=>{"xlinux.nist.gov"=>"\n\nA highly engineered variant of top-down radix sort where attributes of the key are described so the algorithm can allocate buckets and distribute efficiently.\n"}, "Radix sort"=>{"xlinux.nist.gov"=>"\n\nA multiple pass distribution sort algorithm that distributes each item to a bucket according to part of the item's key beginning with the least significant part of the key. After each pass, items are collected from the buckets, keeping the items in order, then redistributed according to the next most significant part of the key.\n", "wolfram"=>"\nNational Institute of Standards and Technology. \"Radix Sort.\" http://www.nist.gov/dads/HTML/radixsort.html.\nThe #1 tool for creating Demonstrations and anything technical.Explore anything with the first computational knowledge engine."}, "Heapsort"=>{"xlinux.nist.gov"=>"\n\nA sort algorithm that builds a heap, then repeatedly extracts the maximum item.  Run time is  O(n log n).\n", "wolfram"=>"\nAn sorting algorithm\n which is not quite as fast as quicksort. It is a \"sort-in-place\"\n algorithm and requires no auxiliary storage, which makes it particularly concise\n and elegant to implement.\n\nKnuth, D. E. The Art of Computer Programming, Vol. 3: Sorting and Searching, 2nd ed.\n Reading, MA: Addison-Wesley, pp. 144-148, 1998.\n"}, "Selection sort"=>{"wolfram"=>"\nA sorting algorithm which makes  passes over a set\n of  elements, in each pass selecting the smallest element\n and deleting it from the set. This algorithm has running time , compared\n to  for the best algorithms (Skiena 1990, p. 14).\n", "xlinux.nist.gov"=>"\n\nA sort algorithm that repeatedly looks through remaining items to find the least one and moves it to its final location.  The run time is Θ(n²), where n is the number of elements.  The number of swaps is  O(n).\n"}, "Smoothsort"=>{"xlinux.nist.gov"=>"\n\nA variant of heapsort that takes advantage of a partially ordered table.  Performance is O(n) when input is sorted and O(n log n)  performance for worst case.\n"}, "Bitonic sorter"=>{"xlinux.nist.gov"=>"\n\nCompare, and swap if necessary, pairs of elements in parallel. Subsets are sorted then merged.\n"}, "Pancake sorting"=>{"wolfram"=>"\nAssume that  numbered pancakes are stacked, and that\n a spatula can be used to reverse the order of the top  pancakes for . Then the pancake sorting problem asks\n how many such \"prefix reversals\" are sufficient to sort an arbitrary stack\n (Skiena 1990, p. 48).\n"}, "Topological sort"=>{"xlinux.nist.gov"=>"\n\nTo arrange items when some pairs of items have no comparison, that is, according to a partial order.\n", "wolfram"=>"\nA topological sort is a permutation  of the vertices\n of a graph such that an edge  implies that\n  appears before  in  (Skiena 1990, p. 208).\n Only directed acyclic graphs can be topologically\n sorted. The topological sort of a graph can be computed using TopologicalSort[g]\n in the Mathematica\n package Combinatorica` .\n"}, "Samplesort"=>{}}

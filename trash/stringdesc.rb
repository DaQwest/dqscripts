# encoding: UTF-8

@stringdesc = {"String searching algorithm"=>{"xlinux.nist.gov"=>"\n\nThe problem of finding occurrence(s) of a pattern string  within another string or body of text.  There are many different algorithms for efficient searching.\n"}, "Aho–Corasick string matching algorithm"=>{"xlinux.nist.gov"=>"\n\nA multiple string matching algorithm that constructs a  finite state machine from a pattern (list of keywords), then uses the machine to locate all occurrences of the keywords in a body of text.\n"}, "Apostolico–Giancarlo algorithm"=>{"xlinux.nist.gov"=>"\n\n(no definition here, yet, but\nyou can help.)\n"}, "Bitap algorithm"=>{}, "Boyer–Moore string search algorithm"=>{}, "Boyer–Moore–Horspool algorithm"=>{"xlinux.nist.gov"=>"\n\nA string matching algorithm that compares characters from the end of the pattern to its beginning.  When characters don't match, searching jumps to the next matching position in the pattern.\n"}, "Commentz-Walter algorithm"=>{"xlinux.nist.gov"=>"\n\nA multiple string matching algorithm that compares from the end of the pattern, like Boyer-Moore, using a finite state machine, like Aho-Corasick.\n"}, "Knuth–Morris–Pratt algorithm"=>{"xlinux.nist.gov"=>"\n\nA string matching algorithm that turns the search string into a finite state machine, then runs the machine with the string to be searched as the input string.  Execution time is O(m+n), where m is the length of the search string, and n is the length of the string to be searched.\n"}, "Levenshtein automaton"=>{}, "Rabin–Karp algorithm"=>{"xlinux.nist.gov"=>"\n\nA string matching algorithm that compares string's  hash values, rather than the strings themselves.  For efficiency, the hash value of the next position in the text is easily computed from the hash value of the current position.\n"}, "Raita Algorithm"=>{}, "Zhu–Takaoka string matching algorithm"=>{"xlinux.nist.gov"=>"\n\nA string matching algorithm that is a variant of the Boyer-Moore algorithm.  It uses two consecutive text characters to compute the bad character shift.  It is faster when the alphabet or pattern is small, but the skip table grows quickly, slowing the pre-processing phase.\n"}, "Lexicographically minimal string rotation"=>{}, "Longest palindromic substring"=>{}, "Longest repeated substring problem"=>{}, "String-to-string correction problem"=>{}, "Edit distance"=>{"wolfram"=>"EditDistance[u, v]gives the edit or Levenshtein distance between strings or vectors u and v.Edit distance between two strings:Edit distance between two vectors:DamerauLevenshteinDistance  HammingDistance  SmithWatermanSimilarity  StringCount  JaccardDissimilarity"}, "Euclidean distance"=>{"wolfram"=>"\nThe distance between two points is the length of the path connecting them. In the plane, the distance between points  and  is given by the Pythagorean\n theorem,\n\nIn Euclidean three-space, the distance between points  and\n  is\n", "xlinux.nist.gov"=>"\n\nThe straight line distance between two points.  In a plane with p1 at (x1, y1) and p2 at (x2, y2), it is  √((x1 - x2)² + (y1 - y2)²).\n"}, "Hamming distance"=>{"wolfram"=>"HammingDistance[u, v] gives the Hamming distance between strings or vectors u and v.Hamming distance between two strings:Hamming distance between two vectors:EditDistance  JaccardDissimilarity  BitXor  DigitCount", "xlinux.nist.gov"=>"\n\nThe number of bits which differ between two binary strings. More formally, the distance between two strings A and B is ∑ | Ai - Bi |.\n"}, "Hellinger distance"=>{}, "Inversion (discrete mathematics)"=>{"wolfram"=>"Permutations are among the most basic elements of discrete mathematics. They are used to represent discrete groups of transformations, and in particular play a key role in group theory, the mathematical study of symmetry. Permutations and groups are important in many aspects of life. We all live on a giant sphere (the Earth) whose rotations are described by the group SO(3) (the special orthogonal group in 3 dimensions). On the micro-scale, the Hungarian-American physicist Eugene Wigner (November 17, 1902–January 1, 1995), who received a share of the Nobel Prize in Physics in 1963, discovered the “electron permutation group”, one of many applications of permutation groups to quantum mechanics."}, "Jaccard index"=>{"wolfram"=>"JaccardDissimilarity[u, v]gives the Jaccard dissimilarity between Boolean vectors u and v.Jaccard dissimilarity between two Boolean vectors:The elements can also be True and False:MatchingDissimilarity  DiceDissimilarity  SokalSneathDissimilarity  RogersTanimotoDissimilarity  RussellRaoDissimilarity  YuleDissimilarity"}, "Jaro–Winkler distance"=>{"xlinux.nist.gov"=>"\n\nA measure of similarity between two strings.  The Jaro measure is the weighted sum of percentage of matched characters from each file and transposed characters.  Winkler increased this measure for matching initial characters, then rescaled it by a piecewise function, whose intervals and weights depend on the type of string (first name, last name, street, etc.).\n"}, "Lee distance"=>{}, "Overlap coefficient"=>{}, "Sørensen–Dice coefficient"=>{}, "String kernel"=>{}, "Tversky index"=>{}, "Wagner–Fischer algorithm"=>{}, "Sequence alignment"=>{"wolfram"=>"Mathematica includes state-of-the-art algorithms for sequence alignment and comparison, capable of handling strings and lists containing very large numbers of elements.SequenceAlignment — find alignments between sequences, allowing insertion and deletion"}, "Probalign"=>{}}

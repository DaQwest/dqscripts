# encoding: UTF-8

@graphdesc = {"Coloring algorithm"=>{"wolfram"=>"\nA vertex coloring is an assignment of labels or colors to each vertex of a graph such that no edge connects two identically colored vertices. The most common type\n of vertex coloring seeks to minimize the number of colors for a given graph. Such\n a coloring is known as a minimum vertex coloring,\n and the minimum number of colors which with the vertices of a graph  may be colored\n is called the chromatic number, denoted .\n"}, "Hopcroft–Karp algorithm"=>{}, "Hungarian algorithm"=>{"wolfram"=>"\nThe Hungarian algorithm finds a maximum independent edge set on a graph. The algorithm starts with any matching  and constructs a tree via a breadth-first\n search to find an augmenting path, namely a path\n  that starts and finishes at unmatched\n vertices whose first and last edges are not in  and whose edges\n alternate being outside and inside . If the search\n succeeds, the symmetric difference of  and the edges in  yields a matching\n with one more edge than . That edge is\n added, and then another search is performed for a new augmenting\n path. If the search is unsuccessful, the algorithm terminates and  must be the largest-size\n matching.\n", "xlinux.nist.gov"=>"\n\nSolve the assignment problem in polynomial time by marking and unmarking entries and covering and uncovering rows and columns.\n"}, "Prufer sequence"=>{"wolfram"=>"\nAn encoding which provides a bijection between the labeled\n trees on  nodes and strings of  integers chosen\n from an alphabet of the numbers 1 to . A labeled\n tree can be converted to a Prüfer code using LabeledTreeToCode[g]\n in the Mathematica\n package Combinatorica` , and a code can be converted to a labeled\n tree using CodeToLabeledTree[code].\n"}, "Tarjan's off-line least common ancestors algorithm"=>{}, "Topological sorting"=>{"wolfram"=>"\nA topological sort is a permutation  of the vertices\n of a graph such that an edge  implies that\n  appears before  in  (Skiena 1990, p. 208).\n Only directed acyclic graphs can be topologically\n sorted. The topological sort of a graph can be computed using TopologicalSort[g]\n in the Mathematica\n package Combinatorica` .\n"}, "Force-based algorithms (graph drawing)"=>{"wolfram"=>"Mathematica provides functions for the aesthetic drawing of graphs. Algorithms implemented include spring embedding, spring-electrical embedding, high-dimensional embedding, radial drawing, random embedding, circular embedding, and spiral embedding. In addition, algorithms for layered/hierarchical drawing of directed graphs as well as for the drawing of trees are available. These algorithms are implemented via four functions: GraphPlot, GraphPlot3D, LayeredGraphPlot, and TreePlot."}, "Spectral layout"=>{}, "Girvan–Newman algorithm"=>{}, "Hyperlink-Induced Topic Search"=>{"wolfram"=>"HITSCentrality[g] gives a list of authority and hub centralities for the vertices in the graph g.Compute HITS hub and authority centralities:Chart of the data:Rate web pages using hyperlink-induced topic search:"}, "Hubs and authorities"=>{}, "PageRank algorithm"=>{}, "TrustRank algorithm"=>{}, "Dinic's algorithm"=>{}, "Edmonds–Karp algorithm"=>{}, "Ford–Fulkerson algorithm"=>{"xlinux.nist.gov"=>"\n\nGiven a flow function and its corresponding residual graph (a maximum-flow problem), select a path from the source to the sink along which the flow can be increased and increase the flow. Repeat until there are no such paths.\n"}, "Karger's algorithm"=>{}, "Push–relabel algorithm"=>{}, "Edmonds's algorithm"=>{"wolfram"=>"\nThe blossom algorithm (Edmonds 1965) finds a maximum independent edge set in a (possibly weighted) graph. While a maximum\n independent edge set can be found fairly easily for a bipartite\n graph using the Hungarian maximum\n matching algorithm, the general case is more difficult. Edmonds's blossom algorithm\n starts with a maximal independent edge\n set, which it tries to extend to a maximum\n independent edge set using the property that a matching\n is maximum iff the matching does not admit an augmenting\n path.\n"}, "Euclidean minimum spanning tree"=>{}, "Longest path problem"=>{"wolfram"=>"\nThe longest path problem asks to find a path of maximum length in a given graph. The problem is NP-complete, but there exists\n an efficient dynamic programming solution\n for acyclic digraphs.\n\nThe detour matrix is a real symmetric matrix whose th entry is the length of the longest\n path from vertex  to vertex .\n"}, "Minimum spanning tree"=>{"wolfram"=>"\nThe minimum spanning tree of a weighted graph is a set of  edges of minimum total weight which\n form a spanning tree of the graph. When a graph\n is unweighted, any spanning tree is a minimum spanning\n tree.\n", "xlinux.nist.gov"=>"\n\nA minimum-weight tree in a weighted graph which contains all of the graph's vertices.\n"}, "Boruvka's algorithm"=>{"xlinux.nist.gov"=>"\n\nCompute a minimum spanning tree.\n", "wolfram"=>"The #1 tool for creating Demonstrations and anything technical.Explore anything with the first computational knowledge engine.Explore thousands of free applications across science, mathematics, engineering, technology, business, art, finance, social sciences, and more."}, "Kruskal's algorithm"=>{"wolfram"=>"\nAn algorithm for finding a graph's spanning tree of minimum length. It sorts the edges\n of a graph in order of increasing cost and then repeatedly adds edges that bridge\n separate components until the graph is fully connected (Pemmaraju and Skiena 2003,\n p. 336). By negating the weights for each edge, the algorithm can also be used\n to find a maximum spanning tree.\n", "xlinux.nist.gov"=>"\n\nAn algorithm for computing a minimum spanning tree.  It maintains a set of partial minimum spanning trees, and repeatedly adds the shortest edge in the graph whose vertices are in different partial minimum spanning trees.\n"}, "Prim's algorithm"=>{}, "Reverse-delete algorithm"=>{}, "Nonblocking Minimal Spanning Switch"=>{}, "Shortest path problem"=>{"wolfram"=>"\nThe problem of finding the shortest path (a.k.a. graph geodesic) connecting two specific vertices  of a directed\n or undirected graph. The length of the graph geodesic\n between these points  is called\n the graph distance between  and . Common algorithms\n for solving the shortest path problem include the Bellman-Ford\n algorithm and Dijkstra's algorithm.\n", "xlinux.nist.gov"=>"\n\nThe problem of finding the shortest path in a graph  from one vertex to another.  \"Shortest\" may be least number of edges, least total weight, etc.\n"}, "Bellman–Ford algorithm"=>{"xlinux.nist.gov"=>"\n\nAn efficient algorithm to solve the single-source shortest-path problem. Weights may be negative.   The algorithm initializes the distance to the source vertex to 0 and all other vertices to ∞.  It then does V-1 passes (V is the number of vertices) over all edges relaxing, or updating, the distance to the destination of each edge. Finally it checks each edge again to detect negative weight cycles, in which case it returns false.  The time complexity is O(VE), where E is the number of edges.\n", "wolfram"=>"\nAn algorithm for solving the shortest path problem, i.e., finding a graph geodesic between two given\n vertices. Other algorithms that can be used for this purpose include Dijkstra's\n algorithm and reaching algorithm. The algorithm\n is implemented as BellmanFord[g,\n v] in the Mathematica\n package Combinatorica` .\n"}, "Dijkstra's algorithm"=>{"wolfram"=>"\nAn algorithm for finding a graph geodesic, i.e., the shortest path between two graph\n vertices in a graph. It functions by constructing a\n shortest-path tree from the initial vertex to every other vertex in the graph. The\n algorithm is implemented as Dijkstra[g]\n in the Mathematica\n package Combinatorica` .\n", "xlinux.nist.gov"=>"\n\nAn algorithm to find the shortest paths from a single source vertex to all other vertices in a weighted, directed graph.  All weights must be nonnegative.\n"}, "Floyd–Warshall algorithm"=>{"wolfram"=>"\nThe Floyd-Warshall algorithm, also variously known as Floyd's algorithm, the Roy-Floyd algorithm, the Roy-Warshall algorithm, or the WFI algorithm, is an algorithm for\n efficiently and simultaneously finding the shortest paths (i.e., graph\n geodesics) between every pair of vertices in a weighted and potentially directed\n graph.\n", "xlinux.nist.gov"=>"\n\nAn algorithm to solve the all pairs shortest path problem in a weighted, directed graph by multiplying an adjacency-matrix representation of the graph multiple times.  The edges may have negative weights, but no negative weight cycles. The time complexity is Θ (V³).\n"}, "Johnson algorithm"=>{"xlinux.nist.gov"=>"\n\nAn algorithm to solve the all pairs shortest path problem in a sparse weighted, directed graph.  First, it adds a new node with zero weight edges from it to all other nodes, and runs the Bellman-Ford algorithm to check for negative weight cycles and find h(v), the least weight of a path from the new node to node v.  Next it reweights the edges using the nodes' h(v) values.  Finally for each node, it runs Dijkstra's algorithm and stores the computed least weight to other nodes, reweighted using the nodes' h(v) values, as the final weight. The time complexity is O(V²log V + VE).\n"}, "Transitive closure"=>{"wolfram"=>"\nThe transitive closure of a binary relation  on a set  is the minimal\n transitive relation  on  that contains\n . Thus  for any elements\n  and  of  provided that\n there exist , , ...,  with , , and  for all .\n", "xlinux.nist.gov"=>"\n\nAn extension or superset of a binary relation such that whenever (a,b) and (b,c) are in the extension, (a,c) is also in the extension.\n"}, "Traveling salesman problem"=>{"wolfram"=>"\nA problem in graph theory requiring the most efficient (i.e., least total distance) Hamiltonian cycle\n a salesman can take through each of  cities. No general\n method of solution is known, and the problem is NP-hard.\n Solution to the traveling salesman problem is implemented as TravelingSalesman[g]\n in the Mathematica\n package Combinatorica`  and FindShortestTour[v1,\n v2, ...].\n", "xlinux.nist.gov"=>"\n\nFind a path of minimum Euclidean distance between points in a plane which includes each point exactly once and returns to its starting point.\n"}, "Christofides algorithm"=>{"xlinux.nist.gov"=>"\n\n(1) A heuristic algorithm to find a near-optimal solution to the traveling salesman problem.  Step 1: find a minimum spanning tree T.  Step 2: find a perfect matching M among vertices with odd degree.  Step 3: combine the edges of M and T to make a multigraph G.  Step 4: find an Euler cycle in G by skipping vertices already seen.  (2) An algorithm to find the chromatic number of a graph.\n"}, "Nearest neighbour algorithm"=>{"wolfram"=>"\nThe problem in computational geometry of identifying the point from a set of points which is nearest to a given point according\n to some measure of distance. The nearest neighborhood problem involves identifying\n the locus of points lying nearer to the query point than to any other point in the\n set.\n"}, "Knight's Tour"=>{"wolfram"=>"To see full output on this page you need to enable JavaScript in your browser. More info »Zoom in to see an enlarged view of any output.AdvertisementBring Wolfram|Alpha output to life with CDF interactivity."}, "A star algorithm"=>{}, "B star algorithm"=>{}, "Backtracking"=>{"xlinux.nist.gov"=>"\n\nFind a solution by trying one of several choices.  If the choice proves incorrect, computation backtracks or restarts at the point of choice and tries another choice.  It is often convenient to maintain choice points and alternate choices using recursion.\n", "wolfram"=>"\nA method of solving combinatorial problems by means of an algorithm which is allowed to run forward until a dead end is reached, at which point previous steps are retraced\n and the algorithm is allowed to run forward again. Backtracking can greatly reduce\n the amount of work in an exhaustive search. Backtracking is implemented as Backtrack[s,\n partialQ, solutionQ] in the Mathematica\n package Combinatorica` .\n"}, "Beam search"=>{}, "Best-first search"=>{"xlinux.nist.gov"=>"\n\nA state-space search algorithm that considers the estimated best partial solution next.  This is typically implemented with a priority queue.\n"}, "Beam stack search"=>{}, "Priority queue"=>{"xlinux.nist.gov"=>"\n\nAn abstract data type to efficiently support finding the item with the highest priority across a series of operations.  The basic operations are: insert, find-minimum (or maximum), and delete-minimum (or maximum).  Some implementations also efficiently support join two priority queues (meld), delete an arbitrary item, and increase the priority of a item (decrease-key).\n"}, "Bidirectional search"=>{}, "Bloom filter"=>{"xlinux.nist.gov"=>"\n\nA probabilistic algorithm to quickly test membership in a large set using multiple hash functions into a single  array of bits.\n"}, "Breadth-first search"=>{"xlinux.nist.gov"=>"\n\nAny search algorithm that considers neighbors of a vertex, that is, outgoing edges of the vertex's predecessor in the search, before any outgoing edges of the vertex.  Extremes are searched last.  This is typically implemented with a queue.\n"}, "D star algorithm"=>{}, "Incremental heuristic search"=>{}, "Depth-first search"=>{"xlinux.nist.gov"=>"\n\n(1) Any search algorithm that considers outgoing edges (children) of a vertex before any of the vertex's siblings, that is, outgoing  edges of the vertex's predecessor in the search.  Extremes are searched first.  This is easily implemented with recursion.  (2) An algorithm that marks all vertices in a directed graph in the order they are discovered and finished, partitioning the graph into a forest.\n"}, "Iterative deepening depth-first search"=>{}, "Lexicographic breadth-first search"=>{}, "Uniform-cost search"=>{}, "Tree traversal"=>{}, "SSS star algorithm"=>{}, "Bron–Kerbosch algorithm"=>{"wolfram"=>"\nThe Bron-Kerbosch algorithm is an efficient method for finding all maximal\ncliques in a graph.\n\nAkkoyunlu, E. A. \"The Enumeration of Maximal Cliques of Large Graphs.\"\nSIAM J. Comput. 2, 1-6, 1973.\n\nBron, C. and Kerbosch, J. \"Algorithm 457: Finding All Cliques of an Undirected\nGraph.\" Comm. ACM 16, 48-50, 1973.\n"}, "Strongly connected components"=>{"wolfram"=>"\nA strongly connected component is maximal subgraph of a directed graph such that for every pair of vertices\n ,  in the subgraph,\n there is a directed path from  to  and a directed\n path from  to . Tarjan (1972)\n has devised an  algorithm for\n determining strongly connected components, which is implemented in Mathematica\n as StronglyConnectedComponents[g]\n in the Mathematica\n package Combinatorica`  (Skiena 1990, p. 172) and StrongComponents[g]\n in the Mathematica\n package GraphUtilities` .\n", "xlinux.nist.gov"=>"\n\nA strongly connected subgraph, S, of a directed graph, D, such that no vertex of D can be added to S and it still be strongly connected.  Informally, a maximal subgraph in which every vertex is reachable from every other vertex.\n"}, "Path-based strong component algorithm"=>{}, "Kosaraju's algorithm"=>{}, "Tarjan's strongly connected components algorithm"=>{"wolfram"=>"\nA strongly connected component is maximal subgraph of a directed graph such that for every pair of vertices\n ,  in the subgraph,\n there is a directed path from  to  and a directed\n path from  to . Tarjan (1972)\n has devised an  algorithm for\n determining strongly connected components, which is implemented in Mathematica\n as StronglyConnectedComponents[g]\n in the Mathematica\n package Combinatorica`  (Skiena 1990, p. 172) and StrongComponents[g]\n in the Mathematica\n package GraphUtilities` .\n", "xlinux.nist.gov"=>"\n\nA strongly connected subgraph, S, of a directed graph, D, such that no vertex of D can be added to S and it still be strongly connected.  Informally, a maximal subgraph in which every vertex is reachable from every other vertex.\n"}}

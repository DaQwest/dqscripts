# encoding: UTF-8

@dpdesc = {"Dynamic programming"=>{"xlinux.nist.gov"=>"\n\nSolve an optimization problem by caching subproblem solutions (memoization) rather than recomputing them.\n"}, "Approximate string matching"=>{"xlinux.nist.gov"=>"\n\nSearching for approximate (e.g., up to a predefined number of symbol mismatches, insertions, and deletions) occurrences of a pattern string in a text string.  Preprocessing, e.g., building an index, may or may not be allowed.\n"}, "Automatic basis function construction"=>{}, "Backward induction"=>{}, "Bellman equation"=>{}, "Bellman–Ford algorithm"=>{"xlinux.nist.gov"=>"\n\nAn efficient algorithm to solve the single-source shortest-path problem. Weights may be negative.   The algorithm initializes the distance to the source vertex to 0 and all other vertices to ∞.  It then does V-1 passes (V is the number of vertices) over all edges relaxing, or updating, the distance to the destination of each edge. Finally it checks each edge again to detect negative weight cycles, in which case it returns false.  The time complexity is O(VE), where E is the number of edges.\n", "wolfram"=>"\nAn algorithm for solving the shortest path problem, i.e., finding a graph geodesic between two given\n vertices. Other algorithms that can be used for this purpose include Dijkstra's\n algorithm and reaching algorithm. The algorithm\n is implemented as BellmanFord[g,\n v] in the Mathematica\n package Combinatorica` .\n"}, "Bitonic tour"=>{}, "Curse of dimensionality"=>{}, "Damerau–Levenshtein distance"=>{"wolfram"=>"DamerauLevenshteinDistance[u, v]gives the Damerau-Levenshtein distance between strings or vectors u and v.Damerau-Levenshtein distance between two strings:Damerau-Levenshtein distance between two vectors:"}, "Differential dynamic programming"=>{}, "Dynamic time warping"=>{}, "Earley parser"=>{}, "Floyd–Warshall algorithm"=>{"wolfram"=>"\nThe Floyd-Warshall algorithm, also variously known as Floyd's algorithm, the Roy-Floyd algorithm, the Roy-Warshall algorithm, or the WFI algorithm, is an algorithm for\n efficiently and simultaneously finding the shortest paths (i.e., graph\n geodesics) between every pair of vertices in a weighted and potentially directed\n graph.\n", "xlinux.nist.gov"=>"\n\nAn algorithm to solve the all pairs shortest path problem in a weighted, directed graph by multiplying an adjacency-matrix representation of the graph multiple times.  The edges may have negative weights, but no negative weight cycles. The time complexity is Θ (V³).\n"}, "Forward–backward algorithm"=>{}, "Hamilton–Jacobi–Bellman equation"=>{}, "Hirschberg's algorithm"=>{}, "Hunt–McIlroy algorithm"=>{}, "Knapsack problem"=>{"wolfram"=>"To see full output on this page you need to enable JavaScript in your browser. More info »Zoom in to see an enlarged view of any output.AdvertisementBring Wolfram|Alpha output to life with CDF interactivity.", "xlinux.nist.gov"=>"\n\nGiven items of different values and volumes, find the most valuable set of items that fit in a knapsack of fixed volume.\n"}, "Levenshtein distance"=>{"xlinux.nist.gov"=>"\n\n(1) The smallest number of insertions, deletions, and substitutions required to change one string or tree into another.  (2) A Θ(m × n) algorithm to compute the distance between strings, where m and n are the lengths of the strings.\n", "wolfram"=>"DamerauLevenshteinDistance[u, v]gives the Damerau-Levenshtein distance between strings or vectors u and v.Damerau-Levenshtein distance between two strings:Damerau-Levenshtein distance between two vectors:"}, "Longest alternating subsequence"=>{}, "Longest common subsequence problem"=>{"xlinux.nist.gov"=>"\n\nThe problem of finding a maximum length (or maximum weight) subsequence of two or more strings.\n"}, "Longest common substring problem"=>{"xlinux.nist.gov"=>"\n\nThe problem of finding a maximum length (or maximum weight) subsequence of two or more strings.\n"}, "Longest increasing subsequence"=>{"wolfram"=>"\nThe longest increasing scattered subsequence is the longest subsequence of increasing terms, where intervening nonincreasing terms may be dropped. Finding the largest\n scattered subsequence is a much harder problem. The longest increasing scattered\n subsequence of a partition can be found using LongestIncreasingSubsequence[p]\n in the Mathematica\n package Combinatorica` . For example, the longest increasing scattered subsequence\n of the permutation \n is , whereas\n the longest contiguous subsequence is .\n"}, "Markov decision process"=>{}, "Matrix chain multiplication"=>{"xlinux.nist.gov"=>"\n\nGiven a sequence of matrices such that any matrix may be multiplied by the previous matrix, find the best association such that the result is obtained with the minimum  number of arithmetic operations.  One may use dynamic programming to find the best association.\n"}, "Maximum subarray problem"=>{}, "Needleman–Wunsch algorithm"=>{"wolfram"=>"Embed Interactive Demonstration New!Files require Wolfram CDF Player or Mathematica."}, "Optimal stopping"=>{}, "Optimal substructure"=>{}, "Overlapping subproblems"=>{}, "Partially observable Markov decision process"=>{}, "Recursive economics"=>{}, "Shortest common supersequence"=>{"xlinux.nist.gov"=>"\n\nFind the shortest string that contains two or more strings as subsequences.\n"}, "Smith–Waterman algorithm"=>{"xlinux.nist.gov"=>"\n\nA means of searching protein databases to find those with the best alignment.\n"}, "Subset sum problem"=>{"wolfram"=>"\nThere are two problems commonly known as the subset sum problem.\n\nThe first (\"given sum problem\") is the problem of finding what subset of a list of integers has a given sum, which is an integer\n relation problem where the relation coefficients  are 0 or 1.\n"}, "Viscosity solution"=>{}, "Viterbi algorithm"=>{}, "Word wrap"=>{}}
